
## http 版本合集 (基于 TCP/IP 协议的应用层协议)
`本文转自`[@blackdous ：Http系列(-) Http发展历史](https://juejin.cn/post/6844903935640240136)

###   HTTP/0.9

- **不涉及数据包（packet）传输**，主要规定了客户端和服务器之间的通信格式，默认使用 80 端口。
- **只有GET命令**。最早版本是 1991 年发布的 0.9 版。服务器只能回应 HTML 格式的字符串，不能回应别的格式


###   HTTP/1.0

- 增加传输文件的格式。图像、视频、二进制文件。
- 丰富了浏览器与服务器的互动手段。引入了 POST 命令和 HEAD 命令。
- HTTP 请求和回应的格式改动。请求和响应加入 http header。
- 其他包括：**状态码（status code）、多字符集支持、多部分发送（multi-part type）、权限（authorization）、缓存（cache）、内容编码（content encoding）** 等。

`缺点`

- HTTP/1.0 版的主要缺点是，每个 TCP 连接只能发送一个请求。发送数据完毕，连接就关闭，如果还要请求其他资源，就必须再新建一个连接。
- TCP 连接的新建成本很高，因为需要客户端和服务器三次握手，并且开始时发送速率较慢（slow start）。
###   HTTP/1.1

-   **长连接：** 弥补了 HTTP1.0 每次请求都要创建连接的缺点。支持长连接（PersistentConnection）和请求的流水线（Pipelining）处理，在一个 TCP 连接上可以传送多个 HTTP 请求和响应。在 HTTP1.1 中默认开启 Connection： keep-alive，一定程度上。

-   **缓存处理：** 在 HTTP1.0 中主要使用 header 里的If-Modified-Since,Expires来做为缓存判断的标准，HTTP1.1 则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。

-   **带宽优化及网络连接的使用**，HTTP1.0 中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1 则在请求头引入了range 头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。

-   **错误通知的管理**，在 HTTP1.1 中新增了**24 个错误状态响应码**，如 409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。

-   **Host 头处理**，在 HTTP1.0 中认为每台服务器都绑定一个唯一的 IP 地址，因此，请求消息中的 URL 并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个 IP 地址。HTTP1.1 的请求消息和响应消息都应支持 Host 头域，且请求消息中如果没有 Host 头域会报告一个错误（400 Bad Request）。

#### http1.1 method
- GET: 通常用来获取资源
- HEAD: 获取资源的元信息
- POST: 提交数据，即上传数据
- PUT: 修改数据
- DELETE: 删除资源(几乎用不到)
- CONNECT: 建立连接隧道，用于代理服务器
- OPTIONS: 列出可对资源实行的请求方法，用来跨域请求
- TRACE: 追踪请求-响应的传输路径

## SPDY 协议

 >2009 年，谷歌公开了自行研发的 SPDY 协议，主要解决 HTTP/1.1 效率不高的问题。 这个协议在 Chrome 浏览器上证明可行以后，就被当作 HTTP/2 的基础，主要特性都在 HTTP/2 之中得到继承。SPDY 可以说是综合了 HTTPS 和 HTTP 两者有点于一体的传输协议，主要解决：

-   **降低延迟**，针对 HTTP 高延迟的问题，SPDY 优雅的采取了**多路复用（multiplexing）** 。多路复用通过多个请求 stream 共享一个 tcp 连接的方式，解决了 HOL blocking 的问题，降低了延迟同时提高了带宽的利用率。
-   **请求优先级（request prioritization）** 。多路复用带来一个新的问题是，在连接共享的基础之上有可能会导致关键请求被阻塞。SPDY 允许给每个 request 设置优先级，这样重要的请求就会优先得到响应。比如浏览器加载首页，首页的 html 内容应该优先展示，之后才是各种静态资源文件，脚本文件等加载，这样可以保证用户能第一时间看到网页内容。
-   **header 压缩**。前面提到 HTTP1.x 的 header 很多时候都是重复多余的。选择合适的压缩算法可以减小包的大小和数量。
-   **基于 HTTPS 的加密协议传输，大大提高了传输数据的可靠性**。
-   **服务端推送（server push）** ，采用了 SPDY 的网页，例如我的网页有一个 sytle.css 的请求，在客户端收到 sytle.css 数据的同时，服务端会将 sytle.js 的文件推送给客户端，当客户端再次尝试获取 sytle.js 时就可以直接从缓存中获取到，不用再发请求了。

  


###   HTTP/2

http2 和 psdy 区别
-   HTTP2.0 支持明文 HTTP 传输，而 SPDY 强制使用 HTTPS
-   HTTP2.0 消息头的压缩算法采用 HPACK，而非 SPDY 采用的 DEFLATE

http2 新特性：
-   二进制分帧：HTTP/2 的所有帧都采用二进制编码
    -   **HTTP/2 将请求和响应数据分割为更小的帧，并且它们采用二进制编码。** 
    -   相比于HTTP 1.x 的文本格式，二进制协议解析起来更高效。
-   多路复用 (Multiplexing)
    -   **多路复用允许同时通过单一的 HTTP/2 连接发起多重的请求-响应消息**。
-   请求优先级 （解决低效问题）
    -   浏览器可以在发现资源时立即分派请求，指定每个流的优先级，让服务器决定最优的响应次序。这样请求就不必排队了，既节省了时间，也最大限度地利用了每个连接。
-   header 压缩
    -   HTTP1.x 的 header 带有大量信息，而且每次都要**重复发送**，HTTP/2 使用 encoder 来减少需要传输的 header 大小，通讯双方各自**cache 一份 header fields 表**，既避免了重复 header 的传输，又减小了需要传输的大小。

-   服务端推送
    -   **Server Push 即服务端能通过 push 的方式将客户端需要的内容预先推送过去，也叫“cache push”** 。
    
## https




