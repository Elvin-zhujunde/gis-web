# 了解浏览器

-   主流浏览
    器：`IE(Trident内核)`、`Firefox(火狐：Gecko内核)`、`Safari(苹果：webkit内 核)`、`Google Chrome(谷歌：Blink内核)`、`Opera(欧朋：Blink内核)`
-   四大内核：Trident(IE内核) 、 Gecko(Firefox内核) 、 webkit内核 、 Blink(Chrome内核)

1. **什么是兼容问题？**

    答：同样的代码，在不同的浏览器上显示的页面效果不一样

2. **不一样的原因是什么？**

    答：浏览器各浏览器使用了不同的内核，并且它们处理同一件事情的时候思路不同。

3. **为什么浏览器会存在兼容问题？**

    - 同一浏览器，版本越老，存在 bug 越多，相对于版本越新的浏览器，对新属性和标签、新特性支持越少。
    - 不同浏览器，核心技术(内核)不同，标准不同，实现方式也有差异，最终呈现出来在大众面前的效果也是会有差异。
    - 设计师写出了不规范的代码，不规范的代码会使不兼容现象更加突出。

从浏览器内核的角度来看，浏览器兼容性问题可分为以下三类：

-   渲染相关：和 样式 相关的问题，即体现在布局效果上的问题。
-   脚本相关：和 脚本 相关的问题，包括JavaScript和DOM、BOM方面的问题。对于某些浏览器的功能方面的特性，也属于这一类。
-   其他类别：除以上两类问题外的功能性问题，一般是浏览器自身提供的功能，在内核层之上的。

# Event loop

在js的运行环境中，通常伴随着很多事件的发生，比如用户点击、页面渲染、脚本执行、网络请求，等等。为了协调这些事件的处理，浏
览器使用事件循环机制。

`简要来说，事件循环会维护一个或多个任务队列（task queues）`，以上提到的事件作为任务源往队列 中加入任务。有一个持续执行的
线程来处理这些任务，每执行完一个就从队列中 移除它，这就是一次事件循环。

那么JS引擎是如何做到单线程处理同步、异步、计时器各类事件 而不会造成阻塞的呢？这就是我们考究Event Loop的意义所在。

同步和异步的执行顺序

1.  JavaScript将任务分为同步任务和异步任务，首先同步任务进入主线程，碰到异步任务后，将其放入Event Table进行回调函数注 册
2.  当异步任务的触发条件满足条件后，会将其回调函数从Event Table压入Event Queue中。
3.  当主线程里的同步任务执行完毕后，会从Event Queue中读取异步的回调函数。
    -   只要主线程没有任务可以执行了，就会去Event Queue中读取异步的回调函数，这个过程叫做Event Loop这里就需要对同步、异
        步、宏任务、微任务的执行顺序有一个清楚的认知。
    1.  首先执行同步代码，每一个script都属于一个宏任务。
    2.  所有同步代码执行完毕，去查看是否有异步代码需要执行。
    3.  如果有的话执行异步代码中的微任务。
    4.  所以微任务执行后，至此第一轮Event Loop就结束了。（之后就是渲染）
    5.  开始新的一轮Event Loop，开始执行异步任务中的宏任务。 并且在浏览器中 引入了多线程的使用，事件触发线程、定时器触发
        线程、js引擎线程、异步Http请求线程、GUI渲染线程。

# EventLoop 事件循环

`JS`是单线程的，为了防止一个函数执行时间过长阻塞后面的代码，所以会先将同步代码压入执行栈中，依次执行，将异步代码推入异步
队列，异步队列又分为宏任务队列和微任务队列，因为宏任务队列的执行时间较长，所以微任务队列要优先于宏任务队列。微任务队列的
代表就是，`Promise.then`，`MutationObserver`，宏任务的话就是`setImmediate setTimeout setInterval`

JS运行的环境。一般为浏览器或者Node。 在浏览器环境中，有JS 引擎线程和渲染线程，且两个线程互斥。 Node环境中，只有JS 线程。
不同环境执行机制有差异，不同任务进入不同Event Queue队列。 当主程结束，先执行准备好微任务，然后再执行准备好的宏任务，一个
轮询结束。

# **浏览器中的事件环（Event Loop)**

事件环的运行机制是，先会执行栈中的内容，栈中的内容执行后执行微任务，微任务清空后再执行宏任务，先取出一个宏任务，再去执行
微任务，然后在取宏任务清微任务这样不停的循环。

-   eventLoop 是由JS的宿主环境（浏览器）来实现的；

-   事件循环可以简单的描述为以下四个步骤:

    1.  函数入栈，当Stack中执行到异步任务的时候，就将他丢给WebAPIs,接着执行同步任务,直到Stack为空；
    1.  此期间WebAPIs完成这个事件，把回调函数放入队列中等待执行（微任务放到微任务队列，宏任务放到宏任务队列）
    1.  执行栈为空时，Event Loop把微任务队列执行清空；
    1.  微任务队列清空后，进入宏任务队列，取队列的第一项任务放入Stack(栈）中执行，执行完成后，查看微任务队列是否有任务，
        有的话，清空微任务队列。重复4，继续从宏任务中取任务执行，执行完成之后，继续清空微任务，如此反复循环，直至清空所
        有的任务。

浏览器中的任务源(task):

-   `宏任务(macrotask)`：  
    宿主环境提供的，比如浏览器  
    ajax、setTimeout、setInterval、setTmmediate(只兼容ie)、script、requestAnimationFrame、messageChannel、UI渲染、一些浏
    览器api
-   `微任务(microtask)`：  
    语言本身提供的，比如promise.then  
    then、queueMicrotask(基于then)、mutationObserver(浏览器提供)、messageChannel 、mutationObersve

# cookie

-   **value** 值
-   **http-only** 不能通过JS访问，只能http访问什么是http-only？HttpOnly是包含在http返回头Set-Cookie里面的一个附加的
    flag，所以它是后端服务器对cookie设置的一个附加的属性，在生成cookie时使用HttpOnly标志有助于减轻客户端脚本访问受保护
    cookie的风险（如果浏览器支持的话）通过js脚本将无法读取到cookie信息，这样能有效的防止XSS攻击。
-   **secure** 限定在https中访问(xss跨域攻击）
-   **same-site** 规定浏览器不能在跨域请求中携带cookie。。（csrf攻击，跨站脚本攻击）

# 说一下浏览器垃圾回收机制？

**目的：** Node基于V8构建，操作的内存空间有限。当进程超过限制内存限制则会退出，所以为了计算机资源得到充分利用，需要及时
回收内存。

**要点：** 栈垃圾回收、堆垃圾回收、新生区老生区、Scavenge算法、标记-清除算法、标记-整理算法、全停顿、增量标记

---

**答：**

浏览器垃圾回收机制根据数据的存储方式分为**栈垃圾回收**和**堆垃圾回收**。

**栈垃圾回收**的方式非常简便，当一个函数执行结束之后，JavaScript 引擎会通过向下移动 ESP 来销毁该函数保存在栈中的执行上下
文，遵循先进后出的原则。

**堆垃圾回收**，当函数直接结束，栈空间处理完成了，但是堆空间的数据虽然没有被引用，但是还是存储在堆空间中，需要垃圾回收器
将堆空间中的垃圾数据回收。

为了使垃圾回收达到更好的效果，根据对象的生命周期不一样，使用不同的垃圾回收的算法。在 V8 中会把堆分为新生代和老生代两个区
域，新生代中存放的是生存时间短的对象，老生代中存放的生存时间久的对象。**新生区**中使用**Scavenge算法**，**老生区**中使
用**标记-清除算法**和**标记-整理算法**。

---

**Scavenge算法：** 1. 标记：对对象区域中的垃圾进行标记 2. 清除垃圾数据和整理碎片化内存：副垃圾回收器会把这些存活的对象复
制到空闲区域中，并且有序的排列起来，复制后空闲区域就没有内存碎片了 3. 角色翻转：完成复制后，对象区域与空闲区域进行角色翻
转，也就是原来的对象区域变成空闲区域，原来的空闲区域变成了对象区域，这样就完成了垃圾对象的回收操作，同时这种角色翻转的操
作还能让新生代中的这两块区域无限重复使用下去

**标记-清除算法：** 1. 标记：标记阶段就是从一组根元素开始，递归遍历这组根元素，在这个遍历过程中，能到达的元素称为活动对
象，没有到达的元素就可以判断为垃圾数据。 2. 清除：将垃圾数据进行清除。 3. 产生内存碎片：对一块内存多次执行标记 - 清除算
法后，会产生大量不连续的内存碎片。而碎片过多会导致大对象无法分配到足够的连续内存。

**标记-整理算法** 1. 标记：和标记 - 清除的标记过程一样，从一组根元素开始，递归遍历这组根元素，在这个遍历过程中，能到达的
元素标记为活动对象。 2. 整理：让所有存活的对象都向内存的一端移动 3. 清除：清理掉端边界以外的内存 V8 是使用副垃圾回收器和
主垃圾回收器处理垃圾回收的，不过由于 JavaScript 是运行在主线程之上的，一旦执行垃圾回收算法，都需要将正在执行的
JavaScript 脚本暂停下来，待垃圾回收完毕后再恢复脚本执行。我们把这种行为叫做全停顿。 为了降低老生代的垃圾回收而造成的卡
顿，V8 将标记过程分为一个个的子标记过程，同时让垃圾回收标记和 JavaScript 应用逻辑交替进行，直到标记阶段完成，我们把这个
算法称为增量标记（Incremental Marking）算法
