import{T as t}from"../splaytree/splaytree.e3fd5a63.js";const e=134217729,n=33306690738754706e-32;function i(t,e,n,i,s){let r,o,l,h,u=e[0],c=i[0],p=0,g=0;c>u==c>-u?(r=u,u=e[++p]):(r=c,c=i[++g]);let f=0;if(p<t&&g<n)for(c>u==c>-u?(o=u+r,l=r-(o-u),u=e[++p]):(o=c+r,l=r-(o-c),c=i[++g]),r=o,0!==l&&(s[f++]=l);p<t&&g<n;)c>u==c>-u?(o=r+u,h=o-r,l=r-(o-h)+(u-h),u=e[++p]):(o=r+c,h=o-r,l=r-(o-h)+(c-h),c=i[++g]),r=o,0!==l&&(s[f++]=l);for(;p<t;)o=r+u,h=o-r,l=r-(o-h)+(u-h),u=e[++p],r=o,0!==l&&(s[f++]=l);for(;g<n;)o=r+c,h=o-r,l=r-(o-h)+(c-h),c=i[++g],r=o,0!==l&&(s[f++]=l);return 0===r&&0!==f||(s[f++]=r),f}function s(t){return new Float64Array(t)}const r=22204460492503146e-32,o=11093356479670487e-47,l=s(4),h=s(8),u=s(12),c=s(16),p=s(4);function g(t,s,g,f,y,x){const a=(s-x)*(g-y),b=(t-y)*(f-x),E=a-b,m=Math.abs(a+b);return Math.abs(E)>=33306690738754716e-32*m?E:-function(t,s,g,f,y,x,a){let b,E,m,S,d,v,w,R,I,_,P,k,A,O,L,N,$,M;const B=t-y,G=g-y,T=s-x,q=f-x;O=B*q,v=e*B,w=v-(v-B),R=B-w,v=e*q,I=v-(v-q),_=q-I,L=R*_-(O-w*I-R*I-w*_),N=T*G,v=e*T,w=v-(v-T),R=T-w,v=e*G,I=v-(v-G),_=G-I,$=R*_-(N-w*I-R*I-w*_),P=L-$,d=L-P,l[0]=L-(P+d)+(d-$),k=O+P,d=k-O,A=O-(k-d)+(P-d),P=A-N,d=A-P,l[1]=A-(P+d)+(d-N),M=k+P,d=M-k,l[2]=k-(M-d)+(P-d),l[3]=M;let F=function(t,e){let n=e[0];for(let i=1;i<t;i++)n+=e[i];return n}(4,l),z=r*a;if(F>=z||-F>=z)return F;if(d=t-B,b=t-(B+d)+(d-y),d=g-G,m=g-(G+d)+(d-y),d=s-T,E=s-(T+d)+(d-x),d=f-q,S=f-(q+d)+(d-x),0===b&&0===E&&0===m&&0===S)return F;if(z=o*a+n*Math.abs(F),F+=B*S+q*b-(T*m+G*E),F>=z||-F>=z)return F;O=b*q,v=e*b,w=v-(v-b),R=b-w,v=e*q,I=v-(v-q),_=q-I,L=R*_-(O-w*I-R*I-w*_),N=E*G,v=e*E,w=v-(v-E),R=E-w,v=e*G,I=v-(v-G),_=G-I,$=R*_-(N-w*I-R*I-w*_),P=L-$,d=L-P,p[0]=L-(P+d)+(d-$),k=O+P,d=k-O,A=O-(k-d)+(P-d),P=A-N,d=A-P,p[1]=A-(P+d)+(d-N),M=k+P,d=M-k,p[2]=k-(M-d)+(P-d),p[3]=M;const C=i(4,l,4,p,h);O=B*S,v=e*B,w=v-(v-B),R=B-w,v=e*S,I=v-(v-S),_=S-I,L=R*_-(O-w*I-R*I-w*_),N=T*m,v=e*T,w=v-(v-T),R=T-w,v=e*m,I=v-(v-m),_=m-I,$=R*_-(N-w*I-R*I-w*_),P=L-$,d=L-P,p[0]=L-(P+d)+(d-$),k=O+P,d=k-O,A=O-(k-d)+(P-d),P=A-N,d=A-P,p[1]=A-(P+d)+(d-N),M=k+P,d=M-k,p[2]=k-(M-d)+(P-d),p[3]=M;const U=i(C,h,4,p,u);O=b*S,v=e*b,w=v-(v-b),R=b-w,v=e*S,I=v-(v-S),_=S-I,L=R*_-(O-w*I-R*I-w*_),N=E*m,v=e*E,w=v-(v-E),R=E-w,v=e*m,I=v-(v-m),_=m-I,$=R*_-(N-w*I-R*I-w*_),P=L-$,d=L-P,p[0]=L-(P+d)+(d-$),k=O+P,d=k-O,A=O-(k-d)+(P-d),P=A-N,d=A-P,p[1]=A-(P+d)+(d-N),M=k+P,d=M-k,p[2]=k-(M-d)+(P-d),p[3]=M;const Y=i(U,u,4,p,c);return c[Y-1]}(t,s,g,f,y,x,m)}const f=(t,e)=>t.ll.x<=e.x&&e.x<=t.ur.x&&t.ll.y<=e.y&&e.y<=t.ur.y,y=(t,e)=>{if(e.ur.x<t.ll.x||t.ur.x<e.ll.x||e.ur.y<t.ll.y||t.ur.y<e.ll.y)return null;const n=t.ll.x<e.ll.x?e.ll.x:t.ll.x,i=t.ur.x<e.ur.x?t.ur.x:e.ur.x;return{ll:{x:n,y:t.ll.y<e.ll.y?e.ll.y:t.ll.y},ur:{x:i,y:t.ur.y<e.ur.y?t.ur.y:e.ur.y}}};let x=Number.EPSILON;void 0===x&&(x=Math.pow(2,-52));const a=x*x,b=(t,e)=>{if(-x<t&&t<x&&-x<e&&e<x)return 0;const n=t-e;return n*n<a*t*e?0:t<e?-1:1};class E{constructor(){this.tree=new t,this.round(0)}round(t){const e=this.tree.add(t),n=this.tree.prev(e);if(null!==n&&0===b(e.key,n.key))return this.tree.remove(t),n.key;const i=this.tree.next(e);return null!==i&&0===b(e.key,i.key)?(this.tree.remove(t),i.key):t}}const m=new class{constructor(){this.reset()}reset(){this.xRounder=new E,this.yRounder=new E}round(t,e){return{x:this.xRounder.round(t),y:this.yRounder.round(e)}}},S=(t,e)=>t.x*e.y-t.y*e.x,d=(t,e)=>t.x*e.x+t.y*e.y,v=(t,e,n)=>{const i=g(t.x,t.y,e.x,e.y,n.x,n.y);return i>0?-1:i<0?1:0},w=t=>Math.sqrt(d(t,t)),R=(t,e,n)=>{const i={x:e.x-t.x,y:e.y-t.y},s={x:n.x-t.x,y:n.y-t.y};return S(s,i)/w(s)/w(i)},I=(t,e,n)=>{const i={x:e.x-t.x,y:e.y-t.y},s={x:n.x-t.x,y:n.y-t.y};return d(s,i)/w(s)/w(i)},_=(t,e,n)=>0===e.y?null:{x:t.x+e.x/e.y*(n-t.y),y:n},P=(t,e,n)=>0===e.x?null:{x:n,y:t.y+e.y/e.x*(n-t.x)};class k{static compare(t,e){const n=k.comparePoints(t.point,e.point);return 0!==n?n:(t.point!==e.point&&t.link(e),t.isLeft!==e.isLeft?t.isLeft?1:-1:O.compare(t.segment,e.segment))}static comparePoints(t,e){return t.x<e.x?-1:t.x>e.x?1:t.y<e.y?-1:t.y>e.y?1:0}constructor(t,e){void 0===t.events?t.events=[this]:t.events.push(this),this.point=t,this.isLeft=e}link(t){if(t.point===this.point)throw new Error("Tried to link already linked events");const e=t.point.events;for(let n=0,i=e.length;n<i;n++){const t=e[n];this.point.events.push(t),t.point=this.point}this.checkForConsuming()}checkForConsuming(){const t=this.point.events.length;for(let e=0;e<t;e++){const n=this.point.events[e];if(void 0===n.segment.consumedBy)for(let i=e+1;i<t;i++){const t=this.point.events[i];void 0===t.consumedBy&&(n.otherSE.point.events===t.otherSE.point.events&&n.segment.consume(t.segment))}}}getAvailableLinkedEvents(){const t=[];for(let e=0,n=this.point.events.length;e<n;e++){const n=this.point.events[e];n!==this&&!n.segment.ringOut&&n.segment.isInResult()&&t.push(n)}return t}getLeftmostComparator(t){const e=new Map,n=n=>{const i=n.otherSE;e.set(n,{sine:R(this.point,t.point,i.point),cosine:I(this.point,t.point,i.point)})};return(t,i)=>{e.has(t)||n(t),e.has(i)||n(i);const{sine:s,cosine:r}=e.get(t),{sine:o,cosine:l}=e.get(i);return s>=0&&o>=0?r<l?1:r>l?-1:0:s<0&&o<0?r<l?-1:r>l?1:0:o<s?-1:o>s?1:0}}}let A=0;class O{static compare(t,e){const n=t.leftSE.point.x,i=e.leftSE.point.x,s=t.rightSE.point.x,r=e.rightSE.point.x;if(r<n)return 1;if(s<i)return-1;const o=t.leftSE.point.y,l=e.leftSE.point.y,h=t.rightSE.point.y,u=e.rightSE.point.y;if(n<i){if(l<o&&l<h)return 1;if(l>o&&l>h)return-1;const n=t.comparePoint(e.leftSE.point);if(n<0)return 1;if(n>0)return-1;const i=e.comparePoint(t.rightSE.point);return 0!==i?i:-1}if(n>i){if(o<l&&o<u)return-1;if(o>l&&o>u)return 1;const n=e.comparePoint(t.leftSE.point);if(0!==n)return n;const i=t.comparePoint(e.rightSE.point);return i<0?1:i>0?-1:1}if(o<l)return-1;if(o>l)return 1;if(s<r){const n=e.comparePoint(t.rightSE.point);if(0!==n)return n}if(s>r){const n=t.comparePoint(e.rightSE.point);if(n<0)return 1;if(n>0)return-1}if(s!==r){const t=h-o,e=s-n,c=u-l,p=r-i;if(t>e&&c<p)return 1;if(t<e&&c>p)return-1}return s>r?1:s<r||h<u?-1:h>u?1:t.id<e.id?-1:t.id>e.id?1:0}constructor(t,e,n,i){this.id=++A,this.leftSE=t,t.segment=this,t.otherSE=e,this.rightSE=e,e.segment=this,e.otherSE=t,this.rings=n,this.windings=i}static fromRing(t,e,n){let i,s,r;const o=k.comparePoints(t,e);if(o<0)i=t,s=e,r=1;else{if(!(o>0))throw new Error(`Tried to create degenerate segment at [${t.x}, ${t.y}]`);i=e,s=t,r=-1}const l=new k(i,!0),h=new k(s,!1);return new O(l,h,[n],[r])}replaceRightSE(t){this.rightSE=t,this.rightSE.segment=this,this.rightSE.otherSE=this.leftSE,this.leftSE.otherSE=this.rightSE}bbox(){const t=this.leftSE.point.y,e=this.rightSE.point.y;return{ll:{x:this.leftSE.point.x,y:t<e?t:e},ur:{x:this.rightSE.point.x,y:t>e?t:e}}}vector(){return{x:this.rightSE.point.x-this.leftSE.point.x,y:this.rightSE.point.y-this.leftSE.point.y}}isAnEndpoint(t){return t.x===this.leftSE.point.x&&t.y===this.leftSE.point.y||t.x===this.rightSE.point.x&&t.y===this.rightSE.point.y}comparePoint(t){if(this.isAnEndpoint(t))return 0;const e=this.leftSE.point,n=this.rightSE.point,i=this.vector();if(e.x===n.x)return t.x===e.x?0:t.x<e.x?1:-1;const s=(t.y-e.y)/i.y,r=e.x+s*i.x;if(t.x===r)return 0;const o=(t.x-e.x)/i.x,l=e.y+o*i.y;return t.y===l?0:t.y<l?-1:1}getIntersection(t){const e=this.bbox(),n=t.bbox(),i=y(e,n);if(null===i)return null;const s=this.leftSE.point,r=this.rightSE.point,o=t.leftSE.point,l=t.rightSE.point,h=f(e,o)&&0===this.comparePoint(o),u=f(n,s)&&0===t.comparePoint(s),c=f(e,l)&&0===this.comparePoint(l),p=f(n,r)&&0===t.comparePoint(r);if(u&&h)return p&&!c?r:!p&&c?l:null;if(u)return c&&s.x===l.x&&s.y===l.y?null:s;if(h)return p&&r.x===o.x&&r.y===o.y?null:o;if(p&&c)return null;if(p)return r;if(c)return l;const g=((t,e,n,i)=>{if(0===e.x)return P(n,i,t.x);if(0===i.x)return P(t,e,n.x);if(0===e.y)return _(n,i,t.y);if(0===i.y)return _(t,e,n.y);const s=S(e,i);if(0==s)return null;const r={x:n.x-t.x,y:n.y-t.y},o=S(r,e)/s,l=S(r,i)/s;return{x:(t.x+l*e.x+(n.x+o*i.x))/2,y:(t.y+l*e.y+(n.y+o*i.y))/2}})(s,this.vector(),o,t.vector());return null===g?null:f(i,g)?m.round(g.x,g.y):null}split(t){const e=[],n=void 0!==t.events,i=new k(t,!0),s=new k(t,!1),r=this.rightSE;this.replaceRightSE(s),e.push(s),e.push(i);const o=new O(i,r,this.rings.slice(),this.windings.slice());return k.comparePoints(o.leftSE.point,o.rightSE.point)>0&&o.swapEvents(),k.comparePoints(this.leftSE.point,this.rightSE.point)>0&&this.swapEvents(),n&&(i.checkForConsuming(),s.checkForConsuming()),e}swapEvents(){const t=this.rightSE;this.rightSE=this.leftSE,this.leftSE=t,this.leftSE.isLeft=!0,this.rightSE.isLeft=!1;for(let e=0,n=this.windings.length;e<n;e++)this.windings[e]*=-1}consume(t){let e=this,n=t;for(;e.consumedBy;)e=e.consumedBy;for(;n.consumedBy;)n=n.consumedBy;const i=O.compare(e,n);if(0!==i){if(i>0){const t=e;e=n,n=t}if(e.prev===n){const t=e;e=n,n=t}for(let t=0,i=n.rings.length;t<i;t++){const i=n.rings[t],s=n.windings[t],r=e.rings.indexOf(i);-1===r?(e.rings.push(i),e.windings.push(s)):e.windings[r]+=s}n.rings=null,n.windings=null,n.consumedBy=e,n.leftSE.consumedBy=e.leftSE,n.rightSE.consumedBy=e.rightSE}}prevInResult(){return void 0!==this._prevInResult||(this.prev?this.prev.isInResult()?this._prevInResult=this.prev:this._prevInResult=this.prev.prevInResult():this._prevInResult=null),this._prevInResult}beforeState(){if(void 0!==this._beforeState)return this._beforeState;if(this.prev){const t=this.prev.consumedBy||this.prev;this._beforeState=t.afterState()}else this._beforeState={rings:[],windings:[],multiPolys:[]};return this._beforeState}afterState(){if(void 0!==this._afterState)return this._afterState;const t=this.beforeState();this._afterState={rings:t.rings.slice(0),windings:t.windings.slice(0),multiPolys:[]};const e=this._afterState.rings,n=this._afterState.windings,i=this._afterState.multiPolys;for(let o=0,l=this.rings.length;o<l;o++){const t=this.rings[o],i=this.windings[o],s=e.indexOf(t);-1===s?(e.push(t),n.push(i)):n[s]+=i}const s=[],r=[];for(let o=0,l=e.length;o<l;o++){if(0===n[o])continue;const t=e[o],i=t.poly;if(-1===r.indexOf(i))if(t.isExterior)s.push(i);else{-1===r.indexOf(i)&&r.push(i);const e=s.indexOf(t.poly);-1!==e&&s.splice(e,1)}}for(let o=0,l=s.length;o<l;o++){const t=s[o].multiPoly;-1===i.indexOf(t)&&i.push(t)}return this._afterState}isInResult(){if(this.consumedBy)return!1;if(void 0!==this._isInResult)return this._isInResult;const t=this.beforeState().multiPolys,e=this.afterState().multiPolys;switch(z.type){case"union":{const n=0===t.length,i=0===e.length;this._isInResult=n!==i;break}case"intersection":{let n,i;t.length<e.length?(n=t.length,i=e.length):(n=e.length,i=t.length),this._isInResult=i===z.numMultiPolys&&n<i;break}case"xor":{const n=Math.abs(t.length-e.length);this._isInResult=n%2==1;break}case"difference":{const n=t=>1===t.length&&t[0].isSubject;this._isInResult=n(t)!==n(e);break}default:throw new Error(`Unrecognized operation type found ${z.type}`)}return this._isInResult}}class L{constructor(t,e,n){if(!Array.isArray(t)||0===t.length)throw new Error("Input geometry is not a valid Polygon or MultiPolygon");if(this.poly=e,this.isExterior=n,this.segments=[],"number"!=typeof t[0][0]||"number"!=typeof t[0][1])throw new Error("Input geometry is not a valid Polygon or MultiPolygon");const i=m.round(t[0][0],t[0][1]);this.bbox={ll:{x:i.x,y:i.y},ur:{x:i.x,y:i.y}};let s=i;for(let r=1,o=t.length;r<o;r++){if("number"!=typeof t[r][0]||"number"!=typeof t[r][1])throw new Error("Input geometry is not a valid Polygon or MultiPolygon");let e=m.round(t[r][0],t[r][1]);e.x===s.x&&e.y===s.y||(this.segments.push(O.fromRing(s,e,this)),e.x<this.bbox.ll.x&&(this.bbox.ll.x=e.x),e.y<this.bbox.ll.y&&(this.bbox.ll.y=e.y),e.x>this.bbox.ur.x&&(this.bbox.ur.x=e.x),e.y>this.bbox.ur.y&&(this.bbox.ur.y=e.y),s=e)}i.x===s.x&&i.y===s.y||this.segments.push(O.fromRing(s,i,this))}getSweepEvents(){const t=[];for(let e=0,n=this.segments.length;e<n;e++){const n=this.segments[e];t.push(n.leftSE),t.push(n.rightSE)}return t}}class N{constructor(t,e){if(!Array.isArray(t))throw new Error("Input geometry is not a valid Polygon or MultiPolygon");this.exteriorRing=new L(t[0],this,!0),this.bbox={ll:{x:this.exteriorRing.bbox.ll.x,y:this.exteriorRing.bbox.ll.y},ur:{x:this.exteriorRing.bbox.ur.x,y:this.exteriorRing.bbox.ur.y}},this.interiorRings=[];for(let n=1,i=t.length;n<i;n++){const e=new L(t[n],this,!1);e.bbox.ll.x<this.bbox.ll.x&&(this.bbox.ll.x=e.bbox.ll.x),e.bbox.ll.y<this.bbox.ll.y&&(this.bbox.ll.y=e.bbox.ll.y),e.bbox.ur.x>this.bbox.ur.x&&(this.bbox.ur.x=e.bbox.ur.x),e.bbox.ur.y>this.bbox.ur.y&&(this.bbox.ur.y=e.bbox.ur.y),this.interiorRings.push(e)}this.multiPoly=e}getSweepEvents(){const t=this.exteriorRing.getSweepEvents();for(let e=0,n=this.interiorRings.length;e<n;e++){const n=this.interiorRings[e].getSweepEvents();for(let e=0,i=n.length;e<i;e++)t.push(n[e])}return t}}class ${constructor(t,e){if(!Array.isArray(t))throw new Error("Input geometry is not a valid Polygon or MultiPolygon");try{"number"==typeof t[0][0][0]&&(t=[t])}catch(n){}this.polys=[],this.bbox={ll:{x:Number.POSITIVE_INFINITY,y:Number.POSITIVE_INFINITY},ur:{x:Number.NEGATIVE_INFINITY,y:Number.NEGATIVE_INFINITY}};for(let i=0,s=t.length;i<s;i++){const e=new N(t[i],this);e.bbox.ll.x<this.bbox.ll.x&&(this.bbox.ll.x=e.bbox.ll.x),e.bbox.ll.y<this.bbox.ll.y&&(this.bbox.ll.y=e.bbox.ll.y),e.bbox.ur.x>this.bbox.ur.x&&(this.bbox.ur.x=e.bbox.ur.x),e.bbox.ur.y>this.bbox.ur.y&&(this.bbox.ur.y=e.bbox.ur.y),this.polys.push(e)}this.isSubject=e}getSweepEvents(){const t=[];for(let e=0,n=this.polys.length;e<n;e++){const n=this.polys[e].getSweepEvents();for(let e=0,i=n.length;e<i;e++)t.push(n[e])}return t}}class M{static factory(t){const e=[];for(let n=0,i=t.length;n<i;n++){const i=t[n];if(!i.isInResult()||i.ringOut)continue;let s=null,r=i.leftSE,o=i.rightSE;const l=[r],h=r.point,u=[];for(;s=r,r=o,l.push(r),r.point!==h;)for(;;){const t=r.getAvailableLinkedEvents();if(0===t.length){const t=l[0].point,e=l[l.length-1].point;throw new Error(`Unable to complete output ring starting at [${t.x}, ${t.y}]. Last matching segment found ends at [${e.x}, ${e.y}].`)}if(1===t.length){o=t[0].otherSE;break}let n=null;for(let e=0,s=u.length;e<s;e++)if(u[e].point===r.point){n=e;break}if(null!==n){const t=u.splice(n)[0],i=l.splice(t.index);i.unshift(i[0].otherSE),e.push(new M(i.reverse()));continue}u.push({index:l.length,point:r.point});const i=r.getLeftmostComparator(s);o=t.sort(i)[0].otherSE;break}e.push(new M(l))}return e}constructor(t){this.events=t;for(let e=0,n=t.length;e<n;e++)t[e].segment.ringOut=this;this.poly=null}getGeom(){let t=this.events[0].point;const e=[t];for(let h=1,u=this.events.length-1;h<u;h++){const n=this.events[h].point,i=this.events[h+1].point;0!==v(n,t,i)&&(e.push(n),t=n)}if(1===e.length)return null;const n=e[0],i=e[1];0===v(n,t,i)&&e.shift(),e.push(e[0]);const s=this.isExteriorRing()?1:-1,r=this.isExteriorRing()?0:e.length-1,o=this.isExteriorRing()?e.length:-1,l=[];for(let h=r;h!=o;h+=s)l.push([e[h].x,e[h].y]);return l}isExteriorRing(){if(void 0===this._isExteriorRing){const t=this.enclosingRing();this._isExteriorRing=!t||!t.isExteriorRing()}return this._isExteriorRing}enclosingRing(){return void 0===this._enclosingRing&&(this._enclosingRing=this._calcEnclosingRing()),this._enclosingRing}_calcEnclosingRing(){let t=this.events[0];for(let i=1,s=this.events.length;i<s;i++){const e=this.events[i];k.compare(t,e)>0&&(t=e)}let e=t.segment.prevInResult(),n=e?e.prevInResult():null;for(;;){if(!e)return null;if(!n)return e.ringOut;if(n.ringOut!==e.ringOut)return n.ringOut.enclosingRing()!==e.ringOut?e.ringOut:e.ringOut.enclosingRing();e=n.prevInResult(),n=e?e.prevInResult():null}}}class B{constructor(t){this.exteriorRing=t,t.poly=this,this.interiorRings=[]}addInterior(t){this.interiorRings.push(t),t.poly=this}getGeom(){const t=[this.exteriorRing.getGeom()];if(null===t[0])return null;for(let e=0,n=this.interiorRings.length;e<n;e++){const n=this.interiorRings[e].getGeom();null!==n&&t.push(n)}return t}}class G{constructor(t){this.rings=t,this.polys=this._composePolys(t)}getGeom(){const t=[];for(let e=0,n=this.polys.length;e<n;e++){const n=this.polys[e].getGeom();null!==n&&t.push(n)}return t}_composePolys(t){const e=[];for(let n=0,i=t.length;n<i;n++){const i=t[n];if(!i.poly)if(i.isExteriorRing())e.push(new B(i));else{const t=i.enclosingRing();t.poly||e.push(new B(t)),t.poly.addInterior(i)}}return e}}class T{constructor(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:O.compare;this.queue=e,this.tree=new t(n),this.segments=[]}process(t){const e=t.segment,n=[];if(t.consumedBy)return t.isLeft?this.queue.remove(t.otherSE):this.tree.remove(e),n;const i=t.isLeft?this.tree.add(e):this.tree.find(e);if(!i)throw new Error(`Unable to find segment #${e.id} [${e.leftSE.point.x}, ${e.leftSE.point.y}] -> [${e.rightSE.point.x}, ${e.rightSE.point.y}] in SweepLine tree.`);let s,r,o=i,l=i;for(;void 0===s;)o=this.tree.prev(o),null===o?s=null:void 0===o.key.consumedBy&&(s=o.key);for(;void 0===r;)l=this.tree.next(l),null===l?r=null:void 0===l.key.consumedBy&&(r=l.key);if(t.isLeft){let i=null;if(s){const t=s.getIntersection(e);if(null!==t&&(e.isAnEndpoint(t)||(i=t),!s.isAnEndpoint(t))){const e=this._splitSafely(s,t);for(let t=0,i=e.length;t<i;t++)n.push(e[t])}}let o=null;if(r){const t=r.getIntersection(e);if(null!==t&&(e.isAnEndpoint(t)||(o=t),!r.isAnEndpoint(t))){const e=this._splitSafely(r,t);for(let t=0,i=e.length;t<i;t++)n.push(e[t])}}if(null!==i||null!==o){let t=null;if(null===i)t=o;else if(null===o)t=i;else{t=k.comparePoints(i,o)<=0?i:o}this.queue.remove(e.rightSE),n.push(e.rightSE);const s=e.split(t);for(let e=0,i=s.length;e<i;e++)n.push(s[e])}n.length>0?(this.tree.remove(e),n.push(t)):(this.segments.push(e),e.prev=s)}else{if(s&&r){const t=s.getIntersection(r);if(null!==t){if(!s.isAnEndpoint(t)){const e=this._splitSafely(s,t);for(let t=0,i=e.length;t<i;t++)n.push(e[t])}if(!r.isAnEndpoint(t)){const e=this._splitSafely(r,t);for(let t=0,i=e.length;t<i;t++)n.push(e[t])}}}this.tree.remove(e)}return n}_splitSafely(t,e){this.tree.remove(t);const n=t.rightSE;this.queue.remove(n);const i=t.split(e);return i.push(n),void 0===t.consumedBy&&this.tree.add(t),i}}const q="undefined"!=typeof process&&{}.POLYGON_CLIPPING_MAX_QUEUE_SIZE||1e6,F="undefined"!=typeof process&&{}.POLYGON_CLIPPING_MAX_SWEEPLINE_SEGMENTS||1e6;const z=new class{run(e,n,i){z.type=e,m.reset();const s=[new $(n,!0)];for(let t=0,c=i.length;t<c;t++)s.push(new $(i[t],!1));if(z.numMultiPolys=s.length,"difference"===z.type){const t=s[0];let e=1;for(;e<s.length;)null!==y(s[e].bbox,t.bbox)?e++:s.splice(e,1)}if("intersection"===z.type)for(let t=0,c=s.length;t<c;t++){const e=s[t];for(let n=t+1,i=s.length;n<i;n++)if(null===y(e.bbox,s[n].bbox))return[]}const r=new t(k.compare);for(let t=0,c=s.length;t<c;t++){const e=s[t].getSweepEvents();for(let t=0,n=e.length;t<n;t++)if(r.insert(e[t]),r.size>q)throw new Error("Infinite loop when putting segment endpoints in a priority queue (queue size too big).")}const o=new T(r);let l=r.size,h=r.pop();for(;h;){const t=h.key;if(r.size===l){const e=t.segment;throw new Error(`Unable to pop() ${t.isLeft?"left":"right"} SweepEvent [${t.point.x}, ${t.point.y}] from segment #${e.id} [${e.leftSE.point.x}, ${e.leftSE.point.y}] -> [${e.rightSE.point.x}, ${e.rightSE.point.y}] from queue.`)}if(r.size>q)throw new Error("Infinite loop when passing sweep line over endpoints (queue size too big).");if(o.segments.length>F)throw new Error("Infinite loop when passing sweep line over endpoints (too many sweep line segments).");const e=o.process(t);for(let n=0,i=e.length;n<i;n++){const t=e[n];void 0===t.consumedBy&&r.insert(t)}l=r.size,h=r.pop()}m.reset();const u=M.factory(o.segments);return new G(u).getGeom()}};var C={union:function(t){for(var e=arguments.length,n=new Array(e>1?e-1:0),i=1;i<e;i++)n[i-1]=arguments[i];return z.run("union",t,n)},intersection:function(t){for(var e=arguments.length,n=new Array(e>1?e-1:0),i=1;i<e;i++)n[i-1]=arguments[i];return z.run("intersection",t,n)},xor:function(t){for(var e=arguments.length,n=new Array(e>1?e-1:0),i=1;i<e;i++)n[i-1]=arguments[i];return z.run("xor",t,n)},difference:function(t){for(var e=arguments.length,n=new Array(e>1?e-1:0),i=1;i<e;i++)n[i-1]=arguments[i];return z.run("difference",t,n)}};export{C as i};
